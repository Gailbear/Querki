@(rc:PlayRequestContext, pageID:querki.pages.PageIDs.PageID, pickled:String)

@import routes.javascript._

<!DOCTYPE html>

@ClientApi = @{ rc.interface[querki.api.ClientApi] }

@isProd = @{ play.api.Play.isProd(play.api.Play.current) }

<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>PLACE TITLE HERE</title>
    
    <link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/jquery-ui-1.10.0.custom.css")">
    <link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/bootstrap.css")">
    <!-- This padding is needed for the top navbar. Bootstrap doc says to put it between the main and responsive CSS: -->
    <style>
      body {
        padding-top: 40px;
      }
    </style>
    <link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/bootstrap-responsive.css")">
    <link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/manifest.css")">
    <link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/main.css")">
    
    <!-- TODO: these should come from a jQuery CDN, instead of locally -->
    <script src="@routes.Assets.at("javascripts/jquery-1.9.0.js")"></script>
    <script src="@routes.Assets.at("javascripts/jquery.manifest-forked.min.js")"></script>
    <script src="@routes.Assets.at("javascripts/jquery-ui-1.10.0.custom.js")"></script>
    <script src="@routes.Assets.at("javascripts/jquery.ui.touch-punch.min.js")"></script>
    <script src="@routes.Assets.at("javascripts/bootstrap.js")"></script>
    <script src="@routes.Assets.at("javascripts/jquery.autosize-min.js")"></script>
    <script src="@routes.Assets.at("javascripts/jquery.raty.min.js")"></script>
    <script src="@routes.Assets.at("javascripts/jquery.histogram.js")"></script>
    <script src="@routes.Assets.at("javascripts/querki-common.js")"></script>
    
    @if(isProd) {
      <script src="@routes.Assets.at("javascripts/querki-client-opt.js")" type="text/javascript"></script>
    } else {
      <script src="@routes.Assets.at("javascripts/querki-client-fastopt.js")" type="text/javascript"></script>
    }

    <script src="@routes.Assets.at("javascripts/querki-client-launcher.js")" type="text/javascript"></script>
    
    <script>
      @Html({
		  implicit val request = rc.request
		  
		  import play.core.Router.JavascriptReverseRoute
		  
		  val callC = classOf[play.core.Router.JavascriptReverseRoute]
		  def getRoutes[T](cont:T):Seq[JavascriptReverseRoute] = {
		    val contC:Class[_] = cont.getClass
		    val allMethods = contC.getMethods
		    val calls = allMethods.filter { method =>
		      val returns = method.getReturnType()
		      callC.isAssignableFrom(returns)
		    }
		    calls.map { call => call.invoke(cont).asInstanceOf[play.core.Router.JavascriptReverseRoute] }
		  }
		  
		  // All routes used by the Client should be placed in here. It doesn't provide proper
		  // static typing, but it's better than doing things in a completely stringly fashion.
		  // Use getRoutes to expose all of the entry points in a controller, or else just name
		  // those routes individually if you want more control:
		  play.api.Routes.javascriptRouter("clientRoutes")(
		    (getRoutes(routes.javascript.Application) ++
		     getRoutes(routes.javascript.ExploreController) ++
		     getRoutes(routes.javascript.AdminController) ++
		     getRoutes(routes.javascript.ClientController)
		    ):_*
		  ).toString
		})
    </script>
    
    <script>
      var pickledJSON = @Html(pickled)
      
      $(function() {
        var client = querki.client.QuerkiClient();
      
        var root = $("#_root").get(0);
        client.pageManager.setRoot(root);
        
        client.pageManager.setImagePath('@routes.Assets.at("images")');
        
        client.dataSetting.unpickleRequest('@Html(ClientApi.pickleRequest(rc))');
        
        client.pageManager.renderPage(@pageID, JSON.stringify(pickledJSON));
      });
    </script>
  </head>
  <body id="_root">
  </body>
</html>
